<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Demucs Player — Responsive + Stable Audio</title>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

<style>
/* （省略：元のスタイルをそのまま使ってください） */
body{background:#0f1115;color:#eaeaf0;margin:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto}
main{max-width:900px;margin:18px auto;padding:14px}
h2 {background: linear-gradient(90deg, #38bdf8, #4ade80);-webkit-background-clip: text;-webkit-text-fill-color: transparent;font-weight: 700;text-align: center; text-shadow: 2px 2px 4px rgba(0,0,0,0.6);}
.top{display:grid;grid-template-columns:90px 1fr 90px;gap:16px;align-items:center}
canvas{width:100%;height:300px;background:#0b0d12;border-radius:12px;display:block}
.btn{background:linear-gradient(90deg,#38bdf8,#4ade80);color:#012;border:none;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer}
.small{font-size:13px;color:#b8cbe0}
.log{background:#071018;color:#9fbfd6;font-size:.85rem;border-radius:8px;padding:8px;max-height:160px;overflow:auto;white-space:pre-wrap}
.v-slider{display:flex;flex-direction:column;align-items:center;height:180px}
.v-label{font-size:13px;color:#b8cbe0;margin-bottom:12px}
.slider-vert{width:150px;height:22px;transform:rotate(-90deg);margin-top:28px}
@media (orientation: portrait) {
  .top { grid-template-columns:1fr; grid-auto-rows:auto; gap:10px; }
  #viz { order: 1; }
  .v-slider { order: 2; flex-direction: row; justify-content: space-between; align-items:center; height:auto; padding:8px 6px; }
  .v-label { margin-bottom:0; margin-right:8px; font-size:12px; width:58px; text-align:left; }
  .slider-vert { transform: none; width:48%; margin-top:0; height:22px; }
  main{padding:12px}
}
@media (max-width:760px) {
  .top { grid-template-columns:1fr; gap:10px; }
  .v-slider{ display:flex; flex-direction:row; justify-content:space-between; align-items:center; height:auto; padding:8px 6px; }
  .v-label{ margin-bottom:0; margin-right:8px; font-size:12px; width:58px; text-align:left; }
  .slider-vert{ transform:none; width:48%; margin-top:0; height:22px; }
  main{padding:10px}
}
</style>
</head>
<body>
<main>
  <h2>Demucs Player</h2>

  <div style="display:flex;gap:8px;margin-bottom:10px">
    <label class="btn" for="zipInput">ZIP読込</label>
    <label class="btn" for="filesInput">2ファイル（vocals / backing）</label>
    <button class="btn" id="playBtn" disabled>再生</button>
    <button class="btn" id="stopBtn" disabled>停止</button>
  </div>

  <div class="top">
    <div class="v-slider" id="vslider-v">
      <div class="v-label">Vocals</div>
      <input id="volV" type="range" min="0" max="1" step="0.01" value="1" class="slider-vert">
    </div>

    <canvas id="viz" aria-hidden="true"></canvas>

    <div class="v-slider" id="vslider-b">
      <div class="v-label">Backing</div>
      <input id="volB" type="range" min="0" max="1" step="0.01" value="1" class="slider-vert">
    </div>
  </div>

  <div style="margin-top:14px">
    <input id="seek" type="range" min="0" max="1" step="0.01" value="0" style="width:100%">
    <div style="display:flex;justify-content:space-between">
      <small id="cur">0:00</small>
      <small id="total">0:00</small>
    </div>

    <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
      <span class="small">Master</span>
      <input id="master" type="range" min="0" max="1" step="0.01" value="1" style="flex:1">
      <span id="filename" class="small">未選択</span>
    </div>

    <pre id="log" class="log">ready</pre>
  </div>
</main>

<input id="zipInput" type="file" accept=".zip" hidden>
<input id="filesInput" type="file" multiple hidden accept=".wav,.mp3,.m4a,.aac,.ogg">

<script>
/* ---------- util ---------- */
const logEl = document.getElementById('log');
const log = (...a) => { logEl.textContent += a.join(' ') + '\n'; logEl.scrollTop = 1e9; };
const fmt = s => !isFinite(s) ? '0:00' : `${Math.floor(s/60)}:${String(Math.floor(s)%60).padStart(2,'0')}`;
let playhead = 0; // 再生位置（常に真実の値）

/* ---------- audio ---------- */
let ctx, analyser, masterGain, gainV, gainB;
let buffers = { vocals: null, backing: null }, sources = {}, startTime = 0, playing = false;

function ensureCtx(){
  if(ctx) return;
  ctx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = ctx.createAnalyser();
  analyser.fftSize = 512;
  analyser.minDecibels = -100;
  analyser.maxDecibels = -20;
  masterGain = ctx.createGain();
  gainV = ctx.createGain(); gainB = ctx.createGain();
  gainV.connect(masterGain); gainB.connect(masterGain);
  masterGain.connect(analyser); analyser.connect(ctx.destination);

  // UI にあるスライダー値を初期ゲインに反映
  gainV.gain.value = Number(document.getElementById('volV').value);
  gainB.gain.value = Number(document.getElementById('volB').value);
  masterGain.gain.value = Number(document.getElementById('master').value);

  log('AudioContext ready');
}

async function decode(ab){
  ensureCtx();
  return new Promise((res, rej)=> ctx.decodeAudioData(ab, res, rej));
}

/* ---------- setTracks (ZIP / files 共通) ---------- */
async function setTracks(vBlob, bBlob, vName, bName){
  // 既存の再生停止（あれば）
  if (playing) stop();

  const vb = await decode(await vBlob.arrayBuffer());
  const bb = await decode(await bBlob.arrayBuffer());

  buffers = { vocals: vb, backing: bb };

  const d = Math.min(vb.duration, bb.duration);
  const seekEl = document.getElementById('seek');
  seekEl.max = d; // 数値として扱われるように
  seekEl.value = 0;

  // 再生位置を 0 に統一
  playhead = 0;
  startTime = 0;
  playing = false;

  document.getElementById('cur').textContent = '0:00';
  document.getElementById('total').textContent = fmt(d);
  playBtn.textContent = '再生';

  document.getElementById('filename').textContent = vName + ' / ' + bName;
  playBtn.disabled = stopBtn.disabled = false;

  log('tracks loaded (reset to 0:00)');
}

/* ---------- ZIP / file input handlers ---------- */
const zipInput = document.getElementById('zipInput');
zipInput.onchange = async () => {
  const file = zipInput.files[0];
  zipInput.value = '';
  if(!file) return;
  log('ZIP select:', file.name);
  try{
    const zip = await JSZip.loadAsync(file);
    const names = Object.keys(zip.files).filter(n => !zip.files[n].dir && /\.(wav|mp3|m4a|aac|ogg)$/i.test(n));
    if(names.length < 2){ alert('ZIP内に音声ファイルが2つ以上必要です'); return; }
    const vName = names.find(n=>/vocals?/i.test(n)) || names[0];
    const bName = names.find(n=>/(inst|back|no[_-]?vocals?)/i.test(n) && n!==vName) || names.find(n=>n!==vName);
    log('ZIP tracks:', vName, bName);
    const vAB = await zip.file(vName).async('arraybuffer');
    const bAB = await zip.file(bName).async('arraybuffer');
    await setTracks(new Blob([vAB]), new Blob([bAB]), vName, bName);
  }catch(e){
    console.error(e);
    log('ZIP load failed:', e && e.message ? e.message : e);
    alert('ZIPの読み込みに失敗しました');
  }
};

const filesInput = document.getElementById('filesInput');
filesInput.onchange = async () => {
  const f = [...filesInput.files];
  filesInput.value = '';
  if (f.length < 2) return alert('2ファイル必要');

  const isNoVocal = name => /no[_-]?vocals?/i.test(name);

const isBack = name =>
  /inst|back|karaoke|伴奏/i.test(name) || isNoVocal(name);

const isVocal = name =>
  !isNoVocal(name) && /vocals?|vocal|vox|歌|ボーカル/i.test(name);

  let vFile = null;
  let bFile = null;

  // ★ 両方を独立して判定
  for (const file of f) {
    if (!vFile && isVocal(file.name)) vFile = file;
    if (!bFile && isBack(file.name))  bFile = file;
  }

  // ★ 片方だけ見つかった場合の補完
  if (vFile && !bFile) bFile = f.find(x => x !== vFile);
  if (bFile && !vFile) vFile = f.find(x => x !== bFile);

  // ★ 両方不明なら順序維持
  if (!vFile || !bFile) {
    log('filename ambiguous, keep order');
    vFile = f[0];
    bFile = f[1];
  }

  log('Vocals:', vFile.name);
  log('Backing:', bFile.name);

  await setTracks(vFile, bFile, vFile.name, bFile.name);
};

/* ---------- play / stop ---------- */
const playBtn = document.getElementById('playBtn');
const stopBtn = document.getElementById('stopBtn');

function stop(){
  Object.values(sources).forEach(s => { try{ s.stop(); }catch{} });
  sources = {};
  if (playing && ctx) {
    // 停止時点を playhead に保存
    playhead = Math.max(0, ctx.currentTime - startTime);
  }
  playing = false;
  playBtn.textContent = '再生';
}

function start(){
  if(!buffers.vocals || !buffers.backing) { alert('トラックが読み込まれていません'); return; }
  ensureCtx();
  ctx.resume();

  // 既存再生を止めてから（再生成が必要）
  stop();

  // 再生開始位置を playhead からにする
  playhead = Number(document.getElementById('seek').value) || playhead || 0;
  startTime = ctx.currentTime - playhead;

  ['vocals','backing'].forEach(k=>{
    const s = ctx.createBufferSource();
    s.buffer = buffers[k];
    s.connect(k === 'vocals' ? gainV : gainB);
    // 再生開始は playhead 秒から
    s.start(0, playhead);
    sources[k] = s;
  });

  playing = true;
  playBtn.textContent = '停止';
}

function getTime(){
  if (playing && ctx) {
    playhead = Math.max(0, ctx.currentTime - startTime);
  }
  return playhead;
}

/* ---------- UI wiring ---------- */
playBtn.onclick = () => playing ? stop() : start();
stopBtn.onclick = stop;

// ゲイン操作
document.getElementById('volV').oninput = (e) => { ensureCtx(); gainV.gain.value = Number(e.target.value); };
document.getElementById('volB').oninput = (e) => { ensureCtx(); gainB.gain.value = Number(e.target.value); };
document.getElementById('master').oninput = (e) => { ensureCtx(); masterGain.gain.value = Number(e.target.value); };

// シーク操作
const seek = document.getElementById('seek');
const cur = document.getElementById('cur');

seek.addEventListener('input', (e) => {
  const v = Number(e.target.value) || 0;
  cur.textContent = fmt(v);
  // 再生中なら即座にその位置から再生し直す
  if (playing) {
    // start() は stop() を呼ぶので再生位置に反映される
    start();
  } else {
    playhead = v;
  }
});

// 定期UI更新（再生中は playhead を反映）
setInterval(()=>{
  if (playing) {
    const t = getTime();
    seek.value = t;
    cur.textContent = fmt(t);
  }
}, 200);

/* ---------- visualizer（元ロジックそのまま） ---------- */
const canvas = document.getElementById('viz');
const ctx2 = canvas.getContext('2d');

function resizeCanvas(){
  const ratio = window.devicePixelRatio || 1;
  canvas.width = Math.floor(canvas.clientWidth * ratio);
  canvas.height = Math.floor(canvas.clientHeight * ratio);
  ctx2.setTransform(ratio,0,0,ratio,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let freqBins = new Uint8Array(256);
let floatFreq = null;
let timeDomain = null;

function drawViz(){
  const cw = canvas.clientWidth;
  const ch = canvas.clientHeight;
  ctx2.clearRect(0,0,cw,ch);

  const leftPad = 80;
  const topMargin = 10;
  const bottomMargin = 44;

  if(analyser && ctx){
    const binCount = analyser.frequencyBinCount;
    if(floatFreq == null || floatFreq.length !== binCount){
      floatFreq = new Float32Array(binCount);
      freqBins = new Uint8Array(binCount);
      timeDomain = new Float32Array(analyser.fftSize);
    }

    analyser.getFloatFrequencyData(floatFreq);
    analyser.getByteFrequencyData(freqBins);
    analyser.getFloatTimeDomainData(timeDomain);

    let sum = 0;
    for(let i=0;i<timeDomain.length;i++) sum += timeDomain[i]*timeDomain[i];
    const rms = Math.sqrt(sum / timeDomain.length) || 0.000001;
    const dbfs = 20 * Math.log10(rms);

    const dBTop = analyser.maxDecibels;
    const dBBottom = analyser.minDecibels;
    const dBRange = dBTop - dBBottom;
    ctx2.font = '11px monospace';
    ctx2.textAlign = 'right';
    ctx2.textBaseline = 'middle';

    const usableH = ch - topMargin - bottomMargin;

    for(let d = Math.ceil(dBBottom/10)*10; d <= dBTop; d += 10){
      const y = topMargin + ((dBTop - d) / dBRange) * usableH;
      ctx2.fillStyle = '#142b31';
      ctx2.fillRect(leftPad - 10, y - 0.5, cw - leftPad - 12, 1);
      ctx2.fillStyle = '#9fbfd6';
      ctx2.fillText(String(d) + ' dB', leftPad - 12, y);
    }

    const nyquist = ctx.sampleRate / 2;
    const usableWidth = cw - leftPad - 12;
    const barWidth = Math.max(1, usableWidth / floatFreq.length);
    for(let i=0;i<floatFreq.length;i++){
      const fdb = floatFreq[i];
      let v = (fdb - dBBottom) / dBRange;
      v = Math.max(0, Math.min(1, v));
      const x = leftPad + i * barWidth;
      const h = v * usableH;
      ctx2.fillStyle = (i%2) ? '#38bdf8' : '#7dd3fc';
      ctx2.fillRect(x, topMargin + (usableH - h), Math.max(1, barWidth*0.9), h);
    }

    const freqs = [50,75,100,150,200,300,400,500,750,1000,1500,2000,3000,5000,8000,10000,15000,20000];
    ctx2.fillStyle = '#cfeff7';
    ctx2.font = '11px monospace';
    ctx2.textAlign = 'center';
    ctx2.textBaseline = 'top';

    const logMin = Math.log10(20);
    const logMax = Math.log10(Math.max(20000, nyquist));
    let lastLabelX = -9999;
    const minLabelSpacing = 40;

    for(const f of freqs){
      if(f > nyquist) continue;
      const lx = Math.log10(Math.max(f,20));
      const pos = (lx - logMin) / (logMax - logMin);
      const x = leftPad + pos * usableWidth;
      if(x - lastLabelX < minLabelSpacing) {
        ctx2.strokeStyle = '#244e57';
        ctx2.beginPath(); ctx2.moveTo(x+0.5, topMargin+2); ctx2.lineTo(x+0.5, topMargin+usableH-2); ctx2.stroke();
        continue;
      }
      ctx2.strokeStyle = '#244e57';
      ctx2.beginPath(); ctx2.moveTo(x+0.5, topMargin+2); ctx2.lineTo(x+0.5, topMargin+usableH-2); ctx2.stroke();
      const label = (f >= 1000) ? (f/1000)+'k' : String(f);
      ctx2.fillStyle = '#cfeff7';
      ctx2.fillText(label, x+0.5, topMargin + usableH + 6);
      lastLabelX = x;
    }

    ctx2.fillStyle = '#9fbfd6';
    ctx2.font = '12px monospace';
    ctx2.textAlign = 'left';
    ctx2.textBaseline = 'top';
    const dbLabel = dbfs.toFixed(1) + ' dBFS';
    ctx2.fillText('Level: ' + dbLabel, leftPad + 6, 6);

    const meterW = Math.min(usableWidth * 0.38, 180);
    const meterH = 8;
    const meterX = leftPad + 6;
    const meterY = 28;
    const meterNorm = Math.max(0, Math.min(1, (dbfs - dBBottom) / dBRange));
    ctx2.fillStyle = '#0e2a2f';
    ctx2.fillRect(meterX, meterY, meterW, meterH);
    ctx2.fillStyle = '#38bdf8';
    ctx2.fillRect(meterX, meterY, meterW * meterNorm, meterH);
    ctx2.strokeStyle = '#072f36';
    ctx2.strokeRect(meterX, meterY, meterW, meterH);

    ctx2.fillStyle = '#9fbfd6';
    ctx2.font = '11px monospace';
    ctx2.textAlign = 'left';
    ctx2.textBaseline = 'bottom';
    ctx2.fillText('Freq (Hz) / Level (dB)', leftPad + 6, ch - 6);

  } else {
    ctx2.fillStyle = '#243447';
    for(let i=0;i<64;i++){
      const x = i*(canvas.clientWidth/64), h = (Math.sin((Date.now()/300)+i)*0.4+0.5)*(canvas.clientHeight/3);
      ctx2.fillRect(x, canvas.clientHeight/2 - h/2, canvas.clientWidth/64*0.85, h);
    }
  }

  requestAnimationFrame(drawViz);
}
requestAnimationFrame(drawViz);
</script>
</body>
</html>
