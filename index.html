<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Demucs Player — GitHub Pages (改良版・詳細ログ付き)</title>

<!-- CDN -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

<style>
  :root{--bg:#0f1115;--panel:#0b0d11;--accent:#38bdf8}
  body{background:linear-gradient(180deg,var(--bg),#050507);color:#e9eef6;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial;margin:0}
  main{max-width:980px;margin:28px auto;padding:18px}
  header{display:flex;align-items:center;gap:12px}
  .controls{display:flex;gap:12px;flex-wrap:wrap;margin:12px 0}
  .panel{background:var(--panel);padding:12px;border-radius:12px}
  canvas{width:100%;height:220px;border-radius:8px;background:#0b0c0e;display:block}
  .meta{display:flex;justify-content:space-between;align-items:center;margin-top:8px}
  .small{font-size:13px;color:#a6b1c6}
  input[type=file]{display:none}
  .btn{background:linear-gradient(90deg,var(--accent),#4ade80);color:#012;border:none;padding:10px 14px;border-radius:10px;font-weight:600}
  .btn:disabled{opacity:.5}
  label{display:block}
  .row{display:flex;gap:8px;align-items:center}
  pre{white-space:pre-wrap;word-break:break-word;background:#071018;padding:8px;border-radius:8px;color:#9fbfd6}
</style>
</head>
<body>
<main>
  <header>
    <h1 style="margin:0;font-size:20px">Demucs Player</h1>
    <div class="small">GitHub Pages 用 — ログ多めの診断版</div>
  </header>

  <section class="panel">
    <div class="controls">
      <button id="loadZip" class="btn">ZIP を読み込む</button>
      <button id="loadFiles" class="btn">2 ファイルを選択</button>
      <button id="play" class="btn" disabled>再生</button>
      <button id="stop" class="btn" disabled>停止</button>
      <label class="row">Loop<input id="loop" type="checkbox"></label>
    </div>

    <label>Vocals ←→ Backing
      <input id="mix" type="range" min="0" max="1" step="0.01" value="0.5">
    </label>

    <label>Master
      <input id="master" type="range" min="0" max="1" step="0.01" value="1">
    </label>

    <div class="meta">
      <div id="filename" class="small">ファイル未選択</div>
      <div class="small" id="status">準備完了</div>
    </div>

    <canvas id="viz"></canvas>
    <h4 class="small">デバッグログ（表示して開発者に見せてください）</h4>
    <pre id="log"></pre>
  </section>

  <!-- file inputs hidden -->
  <input id="zipInput" type="file" accept=".zip" />
  <input id="filesInput" type="file" accept="audio/*" multiple />
</main>

<script>
const logEl = document.getElementById('log');
function log(...args){ console.log(...args); logEl.textContent += Array.from(args).map(a=>typeof a==='object'?JSON.stringify(a):String(a)).join(' ') + '\n'; logEl.scrollTop = 1e9; }

const loadZipBtn = document.getElementById('loadZip');
const loadFilesBtn = document.getElementById('loadFiles');
const playBtn = document.getElementById('play');
const stopBtn = document.getElementById('stop');
const mixSlider = document.getElementById('mix');
const masterSlider = document.getElementById('master');
const loopCheckbox = document.getElementById('loop');
const filenameEl = document.getElementById('filename');
const statusEl = document.getElementById('status');
const zipInput = document.getElementById('zipInput');
const filesInput = document.getElementById('filesInput');
const canvas = document.getElementById('viz');
const ctx = canvas.getContext('2d');

let audioCtx = null;
let analyser = null;
let masterGain = null, gainV = null, gainB = null;
let tracks = { vocals: null, backing: null };
let activeSources = { vocals: null, backing: null };
let isPlaying = false;

function ensureAudioCtx(){
  if(audioCtx) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser(); analyser.fftSize = 512;
    masterGain = audioCtx.createGain(); gainV = audioCtx.createGain(); gainB = audioCtx.createGain();
    gainV.connect(masterGain); gainB.connect(masterGain); masterGain.connect(analyser); analyser.connect(audioCtx.destination);
    log('AudioContext created, state=', audioCtx.state);
    updateControlsFromSliders();
  }catch(e){
    log('AudioContext creation failed:', e);
  }
}

function updateControlsFromSliders(){
  const v = Number(mixSlider.value); const m = Number(masterSlider.value);
  if(gainV && gainB){ gainV.gain.value = v; gainB.gain.value = 1 - v; }
  if(masterGain) masterGain.gain.value = m;
}

async function decodeAudio(arrayBuffer){
  // try decode; if fails return media element fallback
  try{
    ensureAudioCtx();
    const buf = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
    log('decodeAudio OK, length(s):', buf.length, 'sr:', buf.sampleRate);
    return { mode:'buffer', buffer:buf };
  }catch(e){
    log('decodeAudio failed - will fallback to media element:', e);
    const blob = new Blob([arrayBuffer]);
    const url = URL.createObjectURL(blob);
    const el = new Audio(url);
    el.preload = 'auto';
    return { mode:'media', el };
  }
}

async function prepareFromFile(file, role){
  statusEl.textContent = `"${file.name}" を読み込み中...`;
  log('prepareFromFile', file.name, role);
  try{
    const arrayBuffer = await file.arrayBuffer();
    const t = await decodeAudio(arrayBuffer);
    tracks[role] = { fileName: file.name, ...t };
    filenameEl.textContent = `${tracks.vocals?.fileName || '—'}  /  ${tracks.backing?.fileName || '—'}`;
    statusEl.textContent = '読み込み完了';
    playBtn.disabled = false; stopBtn.disabled = false;
    log('track prepared', role, tracks[role]);
  }catch(err){ log('prepare error', err); statusEl.textContent='読み込みエラー'; alert('ファイルの読み込みに失敗しました'); }
}

// ZIP loader
loadZipBtn.addEventListener('click', ()=> zipInput.click());
zipInput.addEventListener('change', async ()=>{
  const file = zipInput.files[0]; zipInput.value = '';
  if(!file) return; statusEl.textContent='ZIP を展開中...'; log('ZIP select', file.name);
  try{
    const zip = await JSZip.loadAsync(file);
    let vEntry=null,bEntry=null;
    zip.forEach((path,entry)=>{
      const n = entry.name.toLowerCase();
      if(n.includes('vocals') && n.match(/\.(wav|mp3|m4a|aac)$/)) vEntry=entry;
      if((n.includes('no_vocals')||n.includes('back')||n.includes('inst')) && n.match(/\.(wav|mp3|m4a|aac)$/)) bEntry=entry;
    });
    if(!vEntry||!bEntry){ statusEl.textContent='対象ファイル不足'; alert('zip内にvocals/backを見つけられません'); return; }
    log('zip entries', vEntry.name, bEntry.name);
    const vBuf = await vEntry.async('arraybuffer');
    const bBuf = await bEntry.async('arraybuffer');
    // decode AFTER user gesture when possible — but here decoding to detect mode is OK
    const t1 = await decodeAudio(vBuf);
    const t2 = await decodeAudio(bBuf);
    tracks.vocals = { fileName: vEntry.name, ...t1 };
    tracks.backing = { fileName: bEntry.name, ...t2 };
    filenameEl.textContent = `${tracks.vocals.fileName} / ${tracks.backing.fileName}`;
    statusEl.textContent = 'ZIP 読み込み完了'; log('tracks set', tracks);
  }catch(e){ log('zip error', e); statusEl.textContent='ZIP読み込み失敗'; alert('ZIP 読み込みに失敗しました'); }
});

// Files loader
loadFilesBtn.addEventListener('click', ()=> filesInput.click());
filesInput.addEventListener('change', async ()=>{
  const files = Array.from(filesInput.files); filesInput.value='';
  if(files.length < 2){ alert('2 ファイルを選択してください'); return; }
  const vocalsFile = files.find(f=>/vocals/i.test(f.name)) || files[0];
  const backingFile = files.find(f=>/no_vocals|back|inst/i.test(f.name)) || files[1];
  await prepareFromFile(vocalsFile, 'vocals');
  await prepareFromFile(backingFile, 'backing');
});

// playback
function stopPlayback(){
  // stop buffer sources
  for(const r of ['vocals','backing']){
    const s = activeSources[r]; if(s && s.stop) try{ s.stop(); }catch(e){ log('stop src err', e); }
    activeSources[r] = null;
  }
  // stop media elements
  for(const r of ['vocals','backing']){
    const t = tracks[r]; if(t?.mode==='media' && t.el){ try{ t.el.pause(); t.el.currentTime=0; }catch(e){ log('pause err', e);} }
  }
  isPlaying=false; playBtn.textContent='再生'; statusEl.textContent='停止中'; log('stopped');
}

async function startPlayback(){
  if(!tracks.vocals || !tracks.backing) return alert('ファイルを読み込んでください');
  ensureAudioCtx();
  if(audioCtx.state === 'suspended'){
    try{ await audioCtx.resume(); log('audioCtx resumed'); }catch(e){ log('resume failed', e); }
  }

  stopPlayback(); updateControlsFromSliders();
  const now = audioCtx.currentTime;

  const bothBuffer = tracks.vocals.mode==='buffer' && tracks.backing.mode==='buffer';
  if(bothBuffer){
    try{
      const sV = audioCtx.createBufferSource(); sV.buffer = tracks.vocals.buffer; sV.connect(gainV);
      const sB = audioCtx.createBufferSource(); sB.buffer = tracks.backing.buffer; sB.connect(gainB);
      if(loopCheckbox.checked){ sV.loop = sB.loop = true; }
      sV.start(now + 0.05); sB.start(now + 0.05);
      activeSources.vocals = sV; activeSources.backing = sB; isPlaying=true; playBtn.textContent='停止'; statusEl.textContent='再生中 (buffer)'; log('started buffer sources');
      // attach end handlers
      sV.onended = ()=>{ log('vocals ended'); if(!loopCheckbox.checked) stopPlayback(); };
      return;
    }catch(e){ log('buffer start failed, fallback to media', e); }
  }

  // Fallback: ensure media elements are connected inside user gesture
  for(const role of ['vocals','backing']){
    const t = tracks[role];
    if(t.mode === 'media'){
      try{
        if(!t.node){ t.node = audioCtx.createMediaElementSource(t.el); t.node.connect(role==='vocals'?gainV:gainB); }
      }catch(e){ log('createMediaElementSource failed', role, e); }
    }else if(t.mode === 'buffer'){
      // create buffer source for this role
      try{
        const s = audioCtx.createBufferSource(); s.buffer = t.buffer; s.connect(role==='vocals'?gainV:gainB); if(loopCheckbox.checked) s.loop = true; s.start(now + 0.05); activeSources[role]=s; log('started temp buffer for', role); }
      catch(e){ log('buffer fallback start failed', role, e); }
    }
  }

  // start media elements (if any)
  const promises = [];
  if(tracks.vocals.mode==='media') promises.push(tracks.vocals.el.play().catch(e=>log('vocals.play failed', e)));
  if(tracks.backing.mode==='media') promises.push(tracks.backing.el.play().catch(e=>log('backing.play failed', e)));
  await Promise.all(promises);
  isPlaying=true; playBtn.textContent='停止'; statusEl.textContent='再生中 (media)'; log('media playback started');
}

play.addEventListener('click', ()=>{ if(isPlaying) stopPlayback(); else startPlayback(); });
stopBtn.addEventListener('click', ()=> stopPlayback());
mixSlider.addEventListener('input', updateControlsFromSliders);
masterSlider.addEventListener('input', updateControlsFromSliders);

// visualizer
let freq = new Uint8Array(512);
function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); if(analyser){ analyser.getByteFrequencyData(freq); const w = canvas.width/freq.length; ctx.fillStyle='#38bdf8'; for(let i=0;i<freq.length;i++){ const h = freq[i]/255*canvas.height; ctx.fillRect(i*w,canvas.height-h,w*0.8,h); } } requestAnimationFrame(draw); }
function resize(){ canvas.width=canvas.clientWidth; canvas.height=canvas.clientHeight; }
window.addEventListener('resize', resize); resize(); draw();

// show supported types
log('canPlayType:', { wav: Audio.prototype.canPlayType && Audio.prototype.canPlayType('audio/wav'), mp3: Audio.prototype.canPlayType && Audio.prototype.canPlayType('audio/mpeg'), m4a: Audio.prototype.canPlayType && Audio.prototype.canPlayType('audio/x-m4a') });

</script>
</body>
</html>
