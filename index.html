<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Demucs Player</title>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

<style>
body{
  background:#0f1115;
  color:#eaeaf0;
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto
}
main{max-width:900px;margin:18px auto;padding:14px}

.top{
  display:grid;
  grid-template-columns:90px 1fr 90px;
  gap:16px;
  align-items:center
}

canvas{
  width:100%;
  height:260px;
  background:#0b0d12;
  border-radius:12px
}

.btn{
  background:linear-gradient(90deg,#38bdf8,#4ade80);
  color:#012;
  border:none;
  padding:8px 12px;
  border-radius:8px;
  font-weight:700;
  cursor:pointer
}

.small{font-size:13px;color:#b8cbe0}

.log{
  background:#071018;
  color:#9fbfd6;
  font-size:.85rem;
  border-radius:8px;
  padding:8px;
  max-height:160px;
  overflow:auto;
  white-space:pre-wrap
}

/* ===== 縦スライダー（被り修正済み） ===== */
.v-slider{
  display:flex;
  flex-direction:column;
  align-items:center;
  height:180px;
}

.v-label{
  font-size:13px;
  color:#b8cbe0;
  margin-bottom:12px; /* 文字と確実に離す */
}

.slider-vert{
  width:150px;
  height:22px;
  transform:rotate(-90deg);
  margin-top:28px;   /* ← 被り防止の本体 */
}
/* ====================================== */

@media(max-width:760px){
  .top{grid-template-columns:1fr}
  .v-slider{display:none}
}
</style>
</head>
<body>

<main>
<h2>Demucs Player</h2>

<div style="display:flex;gap:8px;margin-bottom:10px">
  <label class="btn" for="zipInput">ZIP読込</label>
  <label class="btn" for="filesInput">2ファイル（vocals / backing）</label>
  <button class="btn" id="playBtn" disabled>再生</button>
  <button class="btn" id="stopBtn" disabled>停止</button>
</div>

<div class="top">
  <div class="v-slider">
    <div class="v-label">Vocals</div>
    <input id="volV" type="range"
           min="0" max="1" step="0.01" value="1"
           class="slider-vert">
  </div>

  <canvas id="viz"></canvas>

  <div class="v-slider">
    <div class="v-label">Backing</div>
    <input id="volB" type="range"
           min="0" max="1" step="0.01" value="1"
           class="slider-vert">
  </div>
</div>

<div style="margin-top:14px">
  <input id="seek" type="range" min="0" max="1" step="0.01" value="0">
  <div style="display:flex;justify-content:space-between">
    <small id="cur">0:00</small>
    <small id="total">0:00</small>
  </div>

  <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
    <span class="small">Master</span>
    <input id="master" type="range"
           min="0" max="1" step="0.01" value="1"
           style="flex:1">
    <span id="filename" class="small">未選択</span>
  </div>

  <pre id="log" class="log">ready</pre>
</div>
</main>

<input id="zipInput" type="file" accept=".zip" hidden>
<input id="filesInput"
       type="file"
       multiple
       hidden
       accept=".wav,.mp3,.m4a,.aac,.ogg">

<script>
/* util */
const logEl=document.getElementById('log');
const log=(...a)=>{logEl.textContent+=a.join(' ')+'\\n';logEl.scrollTop=1e9};
const fmt=s=>!isFinite(s)?'0:00':`${Math.floor(s/60)}:${String(Math.floor(s)%60).padStart(2,'0')}`;

/* audio */
let ctx,analyser,masterGain,gainV,gainB;
let buffers={},sources={},startTime=0,pausedAt=0,playing=false;

function ensureCtx(){
  if(ctx)return;
  ctx=new (AudioContext||webkitAudioContext)();
  analyser=ctx.createAnalyser(); analyser.fftSize=512;
  masterGain=ctx.createGain();
  gainV=ctx.createGain(); gainB=ctx.createGain();
  gainV.connect(masterGain); gainB.connect(masterGain);
  masterGain.connect(analyser); analyser.connect(ctx.destination);
  log('AudioContext ready');
}

async function decode(ab){
  ensureCtx();
  return new Promise((res,rej)=>ctx.decodeAudioData(ab,res,rej));
}

/* load */
async function setTracks(vBlob,bBlob,vName,bName){
  const vb=await decode(await vBlob.arrayBuffer());
  const bb=await decode(await bBlob.arrayBuffer());
  buffers={vocals:vb,backing:bb};

  const d=Math.min(vb.duration,bb.duration);
  seek.max=d;
  total.textContent=fmt(d);
  filename.textContent=vName+' / '+bName;
  playBtn.disabled=stopBtn.disabled=false;
  log('tracks loaded');
}

zipInput.onchange=async()=>{
  const zip=await JSZip.loadAsync(zipInput.files[0]);
  const n=Object.keys(zip.files).filter(n=>/\.(wav|mp3|m4a|aac|ogg)$/i.test(n));
  const v=n.find(x=>/vocals/i.test(x))||n[0];
  const b=n.find(x=>/inst|back/i.test(x))||n[1];
  await setTracks(await zip.file(v).async('blob'),
                  await zip.file(b).async('blob'),v,b);
};

filesInput.onchange=async()=>{
  const f=[...filesInput.files];
  if(f.length<2)return alert('2ファイル必要');
  await setTracks(f[0],f[1],f[0].name,f[1].name);
};

/* play */
function stop(){
  Object.values(sources).forEach(s=>{try{s.stop()}catch{}});
  sources={};
  pausedAt = ctx ? ctx.currentTime - startTime : pausedAt;
  playing=false;
  playBtn.textContent='再生';
}

function start(){
  ensureCtx();
  ctx.resume();
  stop();

  const offset = Number(seek.value)||0;
  startTime = ctx.currentTime - offset;

  ['vocals','backing'].forEach(k=>{
    const s=ctx.createBufferSource();
    s.buffer=buffers[k];
    s.connect(k==='vocals'?gainV:gainB);
    s.start(0,offset);
    sources[k]=s;
  });

  playing=true;
  playBtn.textContent='停止';
}

function getTime(){
  return playing ? ctx.currentTime - startTime : pausedAt;
}

/* UI */
playBtn.onclick=()=>playing?stop():start();
stopBtn.onclick=stop;

volV.oninput=()=>gainV&&(gainV.gain.value=volV.value);
volB.oninput=()=>gainB&&(gainB.gain.value=volB.value);
master.oninput=()=>masterGain&&(masterGain.gain.value=master.value);

seek.oninput=()=>{
  cur.textContent=fmt(seek.value);
  if(playing) start();
};

setInterval(()=>{
  if(playing){
    const t=getTime();
    seek.value=t;
    cur.textContent=fmt(t);
  }
},200);

/* viz */
const c=viz.getContext('2d'),freq=new Uint8Array(256);
(function draw(){
  c.clearRect(0,0,viz.width,viz.height);
  if(analyser){
    analyser.getByteFrequencyData(freq);
    const w=viz.width/freq.length,h=viz.height/2;
    for(let i=0;i<freq.length;i+=2){
      const v=freq[i]/255*h;
      c.fillStyle='#38bdf8';
      c.fillRect(i*w,h-v,w*0.8,v);
      c.fillRect(i*w,h,w*0.8,v);
    }
  }
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
