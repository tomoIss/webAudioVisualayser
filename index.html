<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Demucs Player</title>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

<style>
  body{background:#0f1115;color:#eaeaf0}
  main{max-width:900px;margin:auto;padding:16px}
  .top{display:grid;grid-template-columns:80px 1fr 80px;gap:16px;align-items:center}
  .slider-vert{writing-mode:bt-lr;-webkit-appearance:slider-vertical;height:220px}
  canvas{width:100%;height:260px;background:#0b0d12;border-radius:16px}
  .bottom{margin-top:16px}
  .log{margin-top:8px;max-height:160px;overflow:auto;font-size:.8rem;opacity:.85}
</style>
</head>
<body>
<main>
<h2>Demucs Player</h2>

<button id="loadBtn">ZIPを読み込む</button>
<button id="playBtn" disabled>再生</button>

<div class="top">
  <div>
    <label>Vocals
      <input type="range" min="0" max="1" step="0.01" value="1" id="volV" class="slider-vert">
    </label>
  </div>

  <canvas id="viz"></canvas>

  <div>
    <label>Backing
      <input type="range" min="0" max="1" step="0.01" value="1" id="volB" class="slider-vert">
    </label>
  </div>
</div>

<div class="bottom">
  <input type="range" id="seek" min="0" max="1" step="0.01" value="0">
  <div style="display:flex;justify-content:space-between">
    <small id="cur">0:00</small>
    <small id="total">0:00</small>
  </div>

  <label>Master Volume
    <input type="range" id="master" min="0" max="1" step="0.01" value="1">
  </label>

  <pre id="log" class="log"></pre>
</div>
</main>

<input type="file" id="zipInput" accept=".zip" hidden>

<script>
const logEl = document.getElementById('log');
function log(...a){logEl.textContent += a.join(' ')+'\n';}
log('UI ready');

// ==== UI refs ====
const loadBtn = document.getElementById('loadBtn');
const playBtn = document.getElementById('playBtn');
const zipInput = document.getElementById('zipInput');
const seek = document.getElementById('seek');
const curEl = document.getElementById('cur');
const totalEl = document.getElementById('total');
const volV = document.getElementById('volV');
const volB = document.getElementById('volB');
const master = document.getElementById('master');

// ==== Audio ====
let audioCtx, analyser, gV, gB, gM;
let vocalsBuf, backingBuf;
let srcV, srcB;
let startTime = 0;
let offset = 0;
let duration = 0;
let playing = false;

function ensureCtx(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser(); analyser.fftSize = 256;
  gV = audioCtx.createGain(); gB = audioCtx.createGain(); gM = audioCtx.createGain();
  gV.connect(gM); gB.connect(gM); gM.connect(analyser); analyser.connect(audioCtx.destination);
  log('AudioContext created');
}

function startPlay(){
  ensureCtx();
  audioCtx.resume();
  if(srcV) srcV.stop(); if(srcB) srcB.stop();
  srcV = audioCtx.createBufferSource(); srcB = audioCtx.createBufferSource();
  srcV.buffer = vocalsBuf; srcB.buffer = backingBuf;
  srcV.connect(gV); srcB.connect(gB);
  startTime = audioCtx.currentTime;
  srcV.start(0, offset); srcB.start(0, offset);
  playing = true;
}

function stopPlay(){ if(srcV) srcV.stop(); if(srcB) srcB.stop(); playing=false; }

playBtn.onclick = ()=>{
  if(!playing){ startPlay(); playBtn.textContent='停止'; }
  else{ stopPlay(); playBtn.textContent='再生'; }
};

volV.oninput = e=> gV && (gV.gain.value = e.target.value);
volB.oninput = e=> gB && (gB.gain.value = e.target.value);
master.oninput = e=> gM && (gM.gain.value = e.target.value);

seek.oninput = e=>{
  offset = duration * e.target.value;
  if(playing) startPlay();
};

// ==== ZIP ====
loadBtn.onclick = ()=> zipInput.click();
zipInput.onchange = async()=>{
  const file = zipInput.files[0]; zipInput.value='';
  log('ZIP select', file.name);
  const zip = await JSZip.loadAsync(file);
  let v,b;
  zip.forEach((_,e)=>{
    if(e.name.includes('vocals')&&e.name.endsWith('.wav')) v=e;
    if(e.name.includes('no_vocals')&&e.name.endsWith('.wav')) b=e;
  });
  const vb = await v.async('arraybuffer');
  const bb = await b.async('arraybuffer');
  ensureCtx();
  vocalsBuf = await audioCtx.decodeAudioData(vb.slice(0));
  backingBuf = await audioCtx.decodeAudioData(bb.slice(0));
  duration = vocalsBuf.duration;
  totalEl.textContent = fmt(duration);
  playBtn.disabled=false;
  log('tracks set', JSON.stringify({vocals:v.name, backing:b.name, modes:['buffer','buffer']}));
};

// ==== Time update ====
function tick(){
  if(playing){
    const t = offset + (audioCtx.currentTime-startTime);
    curEl.textContent = fmt(t);
    seek.value = Math.min(1, t/duration);
  }
  requestAnimationFrame(tick);
}
function fmt(t){const m=Math.floor(t/60);const s=Math.floor(t%60);return m+':' + s.toString().padStart(2,'0');}
tick();

// ==== Visualizer (center mirror) ====
const canvas = document.getElementById('viz'); const ctx = canvas.getContext('2d');
function resize(){canvas.width=canvas.clientWidth;canvas.height=canvas.clientHeight;}
addEventListener('resize',resize);resize();
const freq = new Uint8Array(128);
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(analyser){
    analyser.getByteFrequencyData(freq);
    const mid = canvas.height/2;
    const w = canvas.width/freq.length;
    for(let i=0;i<freq.length;i++){
      const h = (freq[i]/255)*(canvas.height/2);
      ctx.fillRect(i*w, mid-h, w*0.8, h);
      ctx.fillRect(i*w, mid, w*0.8, h);
    }
  }
  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
