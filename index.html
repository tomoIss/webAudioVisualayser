<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Demucs Player — Buffer-first 安定版 (シーク対応)</title>

<!-- CDN -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

<style>
  :root{--bg:#0f1115;--panel:#0b0d11;--accent:#38bdf8}
  body{background:linear-gradient(180deg,var(--bg),#050507);color:#eaeaf0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial;margin:0}
  main{max-width:980px;margin:28px auto;padding:18px}
  .panel{background:var(--panel);padding:12px;border-radius:12px}
  canvas{width:100%;height:160px;border-radius:8px;background:#0b0c0e;display:block}
  .meta{display:flex;justify-content:space-between;align-items:center;margin-top:8px}
  .small{font-size:13px;color:#a6b1c6}
  input[type=file]{display:none}
  .btn{background:linear-gradient(90deg,var(--accent),#4ade80);color:#012;border:none;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
  label{display:block;margin-top:8px}
  pre{white-space:pre-wrap;word-break:break-word;background:#071018;padding:8px;border-radius:8px;color:#9fbfd6;max-height:200px;overflow:auto}
  .time{font-variant-numeric: tabular-nums;}
  .seek{width:100%}
  #audioPool{display:none}
</style>
</head>
<body>
<main>
  <h1 style="font-size:20px">Demucs Player — Buffer-first 安定版</h1>
  <section class="panel">
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px">
      <label for="zipInput" class="btn">ZIP を読み込む</label>
      <label for="filesInput" class="btn">2 ファイルを選択</label>
      <button id="play" class="btn" disabled>再生</button>
      <button id="stop" class="btn" disabled>停止</button>
      <label style="display:flex;align-items:center;gap:6px"><input id="loop" type="checkbox"> Loop</label>
    </div>

    <label>Vocals ゲイン
      <input id="vocalsGain" type="range" min="0" max="2" step="0.01" value="1">
    </label>
    <label>Backing ゲイン
      <input id="backingGain" type="range" min="0" max="2" step="0.01" value="1">
    </label>
    <label>Master
      <input id="master" type="range" min="0" max="1" step="0.01" value="1">
    </label>

    <div class="meta">
      <div id="filename" class="small">ファイル未選択</div>
      <div class="small" id="status">準備完了</div>
    </div>

    <div style="margin-top:8px;">
      <div style="display:flex;align-items:center;gap:8px">
        <div class="time" id="current">0:00</div>
        <input id="seek" class="seek" type="range" min="0" max="1" step="0.001" value="0">
        <div class="time" id="total">0:00</div>
      </div>
    </div>

    <canvas id="viz"></canvas>
    <h4 class="small">デバッグログ</h4>
    <pre id="log">ログはここに出ます</pre>
  </section>

  <input id="zipInput" type="file" accept=".zip" />
  <input id="filesInput" type="file" accept=".wav,.mp3,.m4a,.aac,audio/*" multiple />

  <div id="audioPool" aria-hidden="true"></div>
</main>

<script>
const logEl = document.getElementById('log');
function log(...items){ console.log(...items); logEl.textContent += items.map(i=>typeof i==='object'?JSON.stringify(i):String(i)).join(' ') + '\n'; logEl.scrollTop = 1e9; }

const playBtn = document.getElementById('play');
const stopBtn = document.getElementById('stop');
const zipInput = document.getElementById('zipInput');
const filesInput = document.getElementById('filesInput');
const audioPool = document.getElementById('audioPool');
const vocalsGainSlider = document.getElementById('vocalsGain');
const backingGainSlider = document.getElementById('backingGain');
const masterSlider = document.getElementById('master');
const seek = document.getElementById('seek');
const currentEl = document.getElementById('current');
const totalEl = document.getElementById('total');
const filenameEl = document.getElementById('filename');
const statusEl = document.getElementById('status');
const canvas = document.getElementById('viz');
const ctx = canvas.getContext('2d');

let audioCtx = null, analyser = null, masterGain = null, gainV = null, gainB = null;
let tracks = { vocals: null, backing: null };
let active = { vocals: null, backing: null }; // for buffer: {node, offset, startedAt}
let isPlaying = false;
let pausedOffset = 0;
let lastSeekSetByUser = false;

function ensureAudioCtx(){ if(audioCtx) return; try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); analyser = audioCtx.createAnalyser(); analyser.fftSize = 512; masterGain = audioCtx.createGain(); gainV = audioCtx.createGain(); gainB = audioCtx.createGain(); gainV.connect(masterGain); gainB.connect(masterGain); masterGain.connect(analyser); analyser.connect(audioCtx.destination); log('AudioContext created state=' + audioCtx.state); updateControlsFromSliders(); }catch(e){ log('AudioContext create failed', e); } }

function updateControlsFromSliders(){ const v = Number(vocalsGainSlider.value); const b = Number(backingGainSlider.value); const m = Number(masterSlider.value); if(gainV && gainB){ gainV.gain.value = v; gainB.gain.value = b; } if(masterGain) masterGain.gain.value = m; const masterScale = Math.max(0, Math.min(1, m)); if(tracks.vocals?.mode==='media' && tracks.vocals.el) tracks.vocals.el.volume = Math.max(0, Math.min(1, v * masterScale)); if(tracks.backing?.mode==='media' && tracks.backing.el) tracks.backing.el.volume = Math.max(0, Math.min(1, b * masterScale)); }

function isAppleDouble(name){ if(!name) return false; const n = name.toLowerCase(); if(n.startsWith('__macosx/')) return true; const parts = name.split('/'); const base = parts[parts.length-1]; if(base.startsWith('._')) return true; if(base.startsWith('.')) return true; return false; }
function fmt(sec){ if(!isFinite(sec)) return '0:00'; sec = Math.max(0, Math.floor(sec)); const m = Math.floor(sec/60); const s = sec%60; return `${m}:${s.toString().padStart(2,'0')}`; }

// decode to buffer; if decode fails return null
async function tryDecode(arrayBuffer){ try{ ensureAudioCtx(); const buf = await audioCtx.decodeAudioData(arrayBuffer.slice(0)); return buf; }catch(e){ log('decodeAudio failed', e && e.message ? e.message : e); return null; } }

function createAudioElementFromBlob(blob, fileName){ const url = URL.createObjectURL(blob); const el = document.createElement('audio'); el.src = url; el.preload='auto'; el.playsInline=true; el.setAttribute('playsinline',''); el.style.display='none'; audioPool.appendChild(el); el.addEventListener('error', (ev)=>{ log('audio element error', fileName, ev); }); el.addEventListener('loadedmetadata', ()=>{ log('loadedmetadata', fileName, 'duration=', el.duration); try{ const dur = calcTotalDuration(); if(isFinite(dur)){ seek.max = dur; totalEl.textContent = fmt(dur); } }catch(e){} }); el.addEventListener('timeupdate', ()=>{ if(!lastSeekSetByUser){ const cur = getCurrentTime(); seek.value = cur; currentEl.textContent = fmt(cur); } }); return { fileName, mode:'media', el, blobUrl: url, blob }; }

function calcTotalDuration(){ if(tracks.vocals?.mode==='buffer' && tracks.backing?.mode==='buffer'){ return Math.min(tracks.vocals.buffer.duration, tracks.backing.buffer.duration); } if(tracks.vocals?.mode==='media' && tracks.backing?.mode==='media' && tracks.vocals.el.duration && tracks.backing.el.duration){ return Math.min(tracks.vocals.el.duration, tracks.backing.el.duration); } // mixed cases
 if(tracks.vocals?.mode==='buffer' && tracks.backing?.mode==='media' && tracks.backing.el.duration) return Math.min(tracks.vocals.buffer.duration, tracks.backing.el.duration);
 if(tracks.vocals?.mode==='media' && tracks.backing?.mode==='buffer' && tracks.vocals.el.duration) return Math.min(tracks.vocals.el.duration, tracks.backing.buffer.duration);
 return Infinity; }

async function loadFromZip(file){ statusEl.textContent='ZIP を展開中...'; log('ZIP select', file.name); try{ const zip = await JSZip.loadAsync(file); const entries=[]; zip.forEach((p,e)=>entries.push(e)); const audioEntries = entries.filter(e=>{ const n=e.name; if(isAppleDouble(n)) return false; return n.match(/\.(wav|mp3|m4a|aac)$/i); }); log('audioEntries', audioEntries.map(e=>e.name)); const findBy=(regex,exclude)=>audioEntries.find(e=>regex.test(e.name)&&e!==exclude); let vEntry = findBy(/(^|\/)\S*vocals\S*\.(wav|mp3|m4a|aac)$/i,null); let bEntry = findBy(/(^|\/)\S*(no_vocals|no-vocals|no\svocals|back|inst|instrumental)\S*\.(wav|mp3|m4a|aac)$/i,vEntry); if(!vEntry) vEntry = audioEntries.find(e=>/vocals/i.test(e.name)); if(!bEntry) bEntry = audioEntries.find(e=>/no_vocals|no-vocals|back|inst|instrumental/i.test(e.name) && e!==vEntry); if(!vEntry||!bEntry){ const distinct=audioEntries.filter(e=>e!==vEntry); if(!vEntry && audioEntries.length>0) vEntry = audioEntries[0]; if(!bEntry && audioEntries.length>1) bEntry = audioEntries.find(e=>e!==vEntry) || distinct[0]; } if(!vEntry||!bEntry){ statusEl.textContent='対象ファイル不足'; alert('zip内に適切な音声ファイルが見つかりません'); log('vEntry/bEntry not found', vEntry && vEntry.name, bEntry && bEntry.name); return; } log('selected entries', vEntry.name, bEntry.name);
 // fetch blobs
 const vBlob = await vEntry.async('blob'); const bBlob = await bEntry.async('blob'); const vAb = await vBlob.arrayBuffer(); const bAb = await bBlob.arrayBuffer();
 // try decode both; prefer buffer mode
 const bufV = await tryDecode(vAb); const bufB = await tryDecode(bAb);
 if(bufV && bufB){ // both decode -> buffer mode
   tracks.vocals = { fileName: vEntry.name, mode:'buffer', buffer: bufV, arrayBuffer: vAb };
   tracks.backing = { fileName: bEntry.name, mode:'buffer', buffer: bufB, arrayBuffer: bAb };
 }else{
   // fallback to media elements (create audio elements from blobs)
   tracks.vocals = await createAudioElementFromBlob(vBlob, vEntry.name);
   tracks.backing = await createAudioElementFromBlob(bBlob, bEntry.name);
 }
 filenameEl.textContent = `${tracks.vocals.fileName} / ${tracks.backing.fileName}`;
 statusEl.textContent = '読み込み完了'; log('tracks set', {vocals:tracks.vocals.fileName, backing:tracks.backing.fileName, modes: [tracks.vocals.mode, tracks.backing.mode]}); playBtn.disabled=false; stopBtn.disabled=false;
 // set seek max if buffers
 const dur = calcTotalDuration(); if(isFinite(dur)){ seek.max = dur; totalEl.textContent = fmt(dur); }
 }catch(e){ log('zip error', e); statusEl.textContent='ZIP読み込み失敗'; alert('ZIP 読み込みに失敗しました'); }
}

zipInput.addEventListener('change', async ()=>{ const f = zipInput.files[0]; zipInput.value=''; if(!f) return; await loadFromZip(f); });

filesInput.addEventListener('change', async ()=>{ const files = Array.from(filesInput.files); filesInput.value=''; if(files.length < 2){ alert('2 ファイルを選択してください'); return; } const vocalsFile = files.find(f=>/vocals/i.test(f.name))||files[0]; const backingFile = files.find(f=>/no_vocals|no-vocals|back|inst|instrumental/i.test(f.name))||files[1]; const vAb = await vocalsFile.arrayBuffer(); const bAb = await backingFile.arrayBuffer(); const bufV = await tryDecode(vAb); const bufB = await tryDecode(bAb); if(bufV && bufB){ tracks.vocals = { fileName: vocalsFile.name, mode:'buffer', buffer: bufV, arrayBuffer: vAb }; tracks.backing = { fileName: backingFile.name, mode:'buffer', buffer: bufB, arrayBuffer: bAb }; }else{ tracks.vocals = await createAudioElementFromBlob(new Blob([vAb]), vocalsFile.name); tracks.backing = await createAudioElementFromBlob(new Blob([bAb]), backingFile.name); } filenameEl.textContent = `${tracks.vocals.fileName} / ${tracks.backing.fileName}`; statusEl.textContent='ファイル読み込み完了'; log('tracks set', {vocals:tracks.vocals.fileName, backing:tracks.backing.fileName}); playBtn.disabled=false; stopBtn.disabled=false; const dur = calcTotalDuration(); if(isFinite(dur)){ seek.max = dur; totalEl.textContent = fmt(dur); } });

// Buffer playback helpers
function startBufferPlayback(offset){ const now = audioCtx.currentTime; // create sources
 const sV = audioCtx.createBufferSource(); sV.buffer = tracks.vocals.buffer; sV.connect(gainV);
 const sB = audioCtx.createBufferSource(); sB.buffer = tracks.backing.buffer; sB.connect(gainB);
 const loop = document.getElementById('loop').checked;
 sV.loop = sB.loop = loop;
 sV.start(now, offset);
 sB.start(now, offset);
 active.vocals = { node: sV, offset, startedAt: now };
 active.backing = { node: sB, offset, startedAt: now };
 // ended handler from one of them
 sV.onended = ()=>{ if(!loop) stopPlayback(); };
}

function stopBufferPlayback(){ for(const k of ['vocals','backing']){ const a = active[k]; if(a && a.node){ try{ a.node.stop(); }catch(e){ } } active[k]=null; } }

function getBufferCurrentOffset(){ const a = active.vocals; if(a && a.startedAt){ return a.offset + (audioCtx.currentTime - a.startedAt); } return pausedOffset || Number(seek.value) || 0; }

// playback control
async function startPlayback(){ if(!tracks.vocals || !tracks.backing) return alert('ファイルを読み込んでください'); ensureAudioCtx(); if(audioCtx.state === 'suspended'){ try{ await audioCtx.resume(); log('audioCtx resumed'); }catch(e){ log('resume failed', e); } }
 // if both buffer mode -> use buffer playback (no media elements)
 if(tracks.vocals.mode==='buffer' && tracks.backing.mode==='buffer'){
   const startAt = Number(seek.value) || 0; stopBufferPlayback(); startBufferPlayback(startAt); isPlaying=true; playBtn.textContent='停止'; statusEl.textContent='再生中 (buffer)'; log('started buffer playback at', startAt); return; }

 // otherwise use media elements (no createMediaElementSource to avoid NotSupportedError). Sync via currentTime.
 // ensure media elements exist and not connected to AudioContext
 for(const role of ['vocals','backing']){
   const t = tracks[role]; if(t.mode==='media' && t.el){ try{ // ensure canplay
       if(t.el.readyState < 3){ await new Promise(resolve=>{ const onCan=()=>{ t.el.removeEventListener('canplay', onCan); resolve(); }; t.el.addEventListener('canplay', onCan); setTimeout(resolve, 2000); }); }
     }catch(e){ log('media ready failed', role, e); }
   }
 }
 // set same currentTime
 const t0 = Number(seek.value) || 0; if(tracks.vocals.el) tracks.vocals.el.currentTime = t0; if(tracks.backing.el) tracks.backing.el.currentTime = t0;
 updateControlsFromSliders(); const promises=[]; if(tracks.vocals.el) promises.push(tracks.vocals.el.play().catch(e=>{ log('vocals.play failed', e.name, e.message); return e; })); if(tracks.backing.el) promises.push(tracks.backing.el.play().catch(e=>{ log('backing.play failed', e.name, e.message); return e; })); const res = await Promise.all(promises); log('play results', res); isPlaying=true; playBtn.textContent='停止'; statusEl.textContent='再生中 (media)'; }

function stopPlayback(){ if(tracks.vocals?.mode==='buffer' || tracks.backing?.mode==='buffer'){ stopBufferPlayback(); pausedOffset = getBufferCurrentOffset(); }
 for(const role of ['vocals','backing']){ const t = tracks[role]; if(t?.mode==='media' && t.el){ try{ t.el.pause(); }catch(e){ log('pause err', e); } } }
 isPlaying=false; playBtn.textContent='再生'; statusEl.textContent='停止中'; log('stopped'); }

playBtn.addEventListener('click', ()=>{ if(isPlaying) stopPlayback(); else startPlayback(); });
stopBtn.addEventListener('click', ()=> stopPlayback());

seek.addEventListener('input', ()=>{ lastSeekSetByUser = true; const t = Number(seek.value); currentEl.textContent = fmt(t); if(isPlaying){ // if playing, perform seek immediately
 const wasPlaying = isPlaying; stopPlayback(); if(wasPlaying) startPlayback(); } });
seek.addEventListener('change', ()=>{ lastSeekSetByUser = false; });

vocalsGainSlider.addEventListener('input', updateControlsFromSliders);
backingGainSlider.addEventListener('input', updateControlsFromSliders);
masterSlider.addEventListener('input', updateControlsFromSliders);

// update seek while playing for both modes
setInterval(()=>{ if(isPlaying && !lastSeekSetByUser){ let cur = 0; if(tracks.vocals?.mode==='buffer' || tracks.backing?.mode==='buffer'){ cur = getBufferCurrentOffset(); } else { cur = getCurrentTime(); } seek.value = cur; currentEl.textContent = fmt(cur); } }, 200);

// visualizer
let freq = new Uint8Array(512);
function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); if(analyser){ analyser.getByteFrequencyData(freq); const w = canvas.width/freq.length; ctx.fillStyle='#38bdf8'; for(let i=0;i<freq.length;i++){ const h = freq[i]/255*canvas.height; ctx.fillRect(i*w,canvas.height-h,w*0.8,h); } } requestAnimationFrame(draw); }
function resize(){ canvas.width=canvas.clientWidth; canvas.height=canvas.clientHeight; }
window.addEventListener('resize', resize); resize(); draw();

log('Supported types:', { wav: Audio.prototype.canPlayType && Audio.prototype.canPlayType('audio/wav'), mp3: Audio.prototype.canPlayType && Audio.prototype.canPlayType('audio/mpeg'), m4a: Audio.prototype.canPlayType && Audio.prototype.canPlayType('audio/x-m4a') });
</script>
</body>
</html>
