<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Demucs Player — Viz 修正版</title>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

<style>
body{background:#0f1115;color:#eaeaf0;margin:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto}
main{max-width:900px;margin:18px auto;padding:14px}
.top{display:grid;grid-template-columns:90px 1fr 90px;gap:16px;align-items:center}
canvas{width:100%;height:300px;background:#0b0d12;border-radius:12px;display:block}
.btn{background:linear-gradient(90deg,#38bdf8,#4ade80);color:#012;border:none;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer}
.small{font-size:13px;color:#b8cbe0}
.log{background:#071018;color:#9fbfd6;font-size:.85rem;border-radius:8px;padding:8px;max-height:160px;overflow:auto;white-space:pre-wrap}
.v-slider{display:flex;flex-direction:column;align-items:center;height:180px}
.v-label{font-size:13px;color:#b8cbe0;margin-bottom:12px}
.slider-vert{width:150px;height:22px;transform:rotate(-90deg);margin-top:28px}
@media(max-width:760px){ .top{grid-template-columns:1fr} .v-slider{display:none} }
.viz-label{font-family:monospace;color:#9fbfd6;font-size:12px}
</style>
</head>
<body>

<main>
<h2>Demucs Player</h2>

<div style="display:flex;gap:8px;margin-bottom:10px">
  <label class="btn" for="zipInput">ZIP読込</label>
  <label class="btn" for="filesInput">2ファイル（vocals / backing）</label>
  <button class="btn" id="playBtn" disabled>再生</button>
  <button class="btn" id="stopBtn" disabled>停止</button>
</div>

<div class="top">
  <div class="v-slider">
    <div class="v-label">Vocals</div>
    <input id="volV" type="range" min="0" max="1" step="0.01" value="1" class="slider-vert">
  </div>

  <canvas id="viz"></canvas>

  <div class="v-slider">
    <div class="v-label">Backing</div>
    <input id="volB" type="range" min="0" max="1" step="0.01" value="1" class="slider-vert">
  </div>
</div>

<div style="margin-top:14px">
  <input id="seek" type="range" min="0" max="1" step="0.01" value="0" style="width:100%">
  <div style="display:flex;justify-content:space-between">
    <small id="cur">0:00</small>
    <small id="total">0:00</small>
  </div>

  <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
    <span class="small">Master</span>
    <input id="master" type="range" min="0" max="1" step="0.01" value="1" style="flex:1">
    <span id="filename" class="small">未選択</span>
  </div>

  <pre id="log" class="log">ready</pre>
</div>
</main>

<input id="zipInput" type="file" accept=".zip" hidden>
<input id="filesInput" type="file" multiple hidden accept=".wav,.mp3,.m4a,.aac,.ogg">

<script>
/* ---------- util ---------- */
const logEl = document.getElementById('log');
const log = (...a) => { logEl.textContent += a.join(' ') + '\n'; logEl.scrollTop = 1e9; };
const fmt = s => !isFinite(s) ? '0:00' : `${Math.floor(s/60)}:${String(Math.floor(s)%60).padStart(2,'0')}`;

/* ---------- audio （既存ロジック維持） ---------- */
let ctx, analyser, masterGain, gainV, gainB;
let buffers = {}, sources = {}, startTime = 0, pausedAt = 0, playing = false;

function ensureCtx(){
  if(ctx) return;
  ctx = new (AudioContext||webkitAudioContext)();
  analyser = ctx.createAnalyser();
  analyser.fftSize = 512;
  analyser.minDecibels = -100;
  analyser.maxDecibels = -20;
  masterGain = ctx.createGain();
  gainV = ctx.createGain(); gainB = ctx.createGain();
  gainV.connect(masterGain); gainB.connect(masterGain);
  masterGain.connect(analyser); analyser.connect(ctx.destination);
  log('AudioContext ready');
}

async function decode(ab){
  ensureCtx();
  return new Promise((res, rej)=> ctx.decodeAudioData(ab, res, rej));
}

/* ---------- load (ZIP arraybuffer 安定パス) ---------- */
async function setTracks(vBlob, bBlob, vName, bName){
  const vb = await decode(await vBlob.arrayBuffer());
  const bb = await decode(await bBlob.arrayBuffer());
  buffers = { vocals: vb, backing: bb };
  const d = Math.min(vb.duration, bb.duration);
  seek.max = d;
  total.textContent = fmt(d);
  filename.textContent = vName + ' / ' + bName;
  playBtn.disabled = stopBtn.disabled = false;
  log('tracks loaded');
}

zipInput.onchange = async () => {
  const file = zipInput.files[0];
  zipInput.value = '';
  if(!file) return;
  log('ZIP select:', file.name);
  try{
    const zip = await JSZip.loadAsync(file);
    const names = Object.keys(zip.files).filter(n => !zip.files[n].dir && /\.(wav|mp3|m4a|aac|ogg)$/i.test(n));
    if(names.length < 2){ alert('ZIP内に音声ファイルが2つ以上必要です'); return; }
    const vName = names.find(n=>/vocals?/i.test(n)) || names[0];
    const bName = names.find(n=>/(inst|back|no[_-]?vocals?)/i.test(n) && n!==vName) || names.find(n=>n!==vName);
    log('ZIP tracks:', vName, bName);
    const vAB = await zip.file(vName).async('arraybuffer');
    const bAB = await zip.file(bName).async('arraybuffer');
    const vBlob = new Blob([vAB]);
    const bBlob = new Blob([bAB]);
    await setTracks(vBlob, bBlob, vName, bName);
  }catch(e){
    console.error(e);
    log('ZIP load failed:', e && e.message ? e.message : e);
    alert('ZIPの読み込みに失敗しました');
  }
};

filesInput.onchange = async () => {
  const f = [...filesInput.files];
  filesInput.value = '';
  if(f.length < 2) return alert('2ファイル必要');
  await setTracks(f[0], f[1], f[0].name, f[1].name);
};

/* ---------- play / stop（既存ロジック維持） ---------- */
function stop(){
  Object.values(sources).forEach(s => { try{ s.stop(); }catch{} });
  sources = {};
  pausedAt = ctx ? ctx.currentTime - startTime : pausedAt;
  playing = false;
  playBtn.textContent = '再生';
}

function start(){
  ensureCtx();
  ctx.resume();
  stop();
  const offset = Number(seek.value) || 0;
  startTime = ctx.currentTime - offset;
  ['vocals','backing'].forEach(k=>{
    const s = ctx.createBufferSource();
    s.buffer = buffers[k];
    s.connect(k === 'vocals' ? gainV : gainB);
    s.start(0, offset);
    sources[k] = s;
  });
  playing = true;
  playBtn.textContent = '停止';
}

function getTime(){ return playing ? ctx.currentTime - startTime : pausedAt; }

/* ---------- UI wiring ---------- */
playBtn.onclick = () => playing ? stop() : start();
stopBtn.onclick = stop;
volV.oninput = () => gainV && (gainV.gain.value = volV.value);
volB.oninput = () => gainB && (gainB.gain.value = volB.value);
master.oninput = () => masterGain && (masterGain.gain.value = master.value);
seek.oninput = () => { cur.textContent = fmt(seek.value); if(playing) start(); };
setInterval(()=>{
  if(playing){
    const t = getTime();
    seek.value = t;
    cur.textContent = fmt(t);
  }
},200);

/* ---------- visualizer（拡張・修正版） ---------- */
const canvas = document.getElementById('viz');
const ctx2 = canvas.getContext('2d');

function resizeCanvas(){
  const ratio = window.devicePixelRatio || 1;
  canvas.width = Math.floor(canvas.clientWidth * ratio);
  canvas.height = Math.floor(canvas.clientHeight * ratio);
  ctx2.setTransform(ratio,0,0,ratio,0,0); // scale to CSS pixels
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let freqBins = new Uint8Array(256); // reassignable -> let
let floatFreq = null;
let timeDomain = null;

function drawViz(){
  const cw = canvas.clientWidth;
  const ch = canvas.clientHeight;
  ctx2.clearRect(0,0,cw,ch);

  if(analyser && ctx){
    const binCount = analyser.frequencyBinCount; // fftSize/2
    if(floatFreq == null || floatFreq.length !== binCount){
      floatFreq = new Float32Array(binCount);
      freqBins = new Uint8Array(binCount);
      timeDomain = new Float32Array(analyser.fftSize);
    }

    analyser.getFloatFrequencyData(floatFreq); // dB floats
    analyser.getByteFrequencyData(freqBins);    // 0-255
    analyser.getFloatTimeDomainData(timeDomain);

    // RMS -> dBFS
    let sum = 0;
    for(let i=0;i<timeDomain.length;i++) sum += timeDomain[i]*timeDomain[i];
    const rms = Math.sqrt(sum / timeDomain.length) || 0.000001;
    const dbfs = 20 * Math.log10(rms);

    // dB scale left
    const dBTop = analyser.maxDecibels;
    const dBBottom = analyser.minDecibels;
    const dBRange = dBTop - dBBottom;
    ctx2.font = '11px monospace';
    ctx2.textAlign = 'right';
    ctx2.textBaseline = 'middle';
    const leftPad = 56;

    // faint horizontal grid + labels
    for(let d = Math.ceil(dBBottom/10)*10; d <= dBTop; d += 10){
      const y = ((dBTop - d) / dBRange) * (ch - 20) + 10;
      ctx2.fillStyle = '#142b31';
      ctx2.fillRect(leftPad - 8, y - 0.5, cw - leftPad - 8, 1);
      ctx2.fillStyle = '#9fbfd6';
      ctx2.fillText(String(d) + ' dB', leftPad - 10, y);
    }

    // spectral bars
    const nyquist = ctx.sampleRate / 2;
    const binFreq = ctx.sampleRate / analyser.fftSize; // freq per FFT bin
    const usableWidth = cw - leftPad - 12;
    const barWidth = Math.max(1, usableWidth / floatFreq.length);
    for(let i=0;i<floatFreq.length;i++){
      const fdb = floatFreq[i];
      let v = (fdb - dBBottom) / dBRange;
      v = Math.max(0, Math.min(1, v));
      const x = leftPad + i * barWidth;
      const h = v * (ch - 40);
      ctx2.fillStyle = (i%2) ? '#38bdf8' : '#7dd3fc';
      ctx2.fillRect(x, ch - 20 - h, Math.max(1, barWidth*0.9), h);
    }

    // frequency markers
    const freqs = [50,100,200,500,1000,2000,5000,10000,20000];
    ctx2.fillStyle = '#cfeff7';
    ctx2.font = '11px monospace';
    ctx2.textAlign = 'center';
    ctx2.textBaseline = 'top';
    for(const f of freqs){
      if(f > nyquist) continue;
      const binIndex = Math.round(f / binFreq);
      const x = leftPad + binIndex * barWidth;
      ctx2.strokeStyle = '#244e57';
      ctx2.beginPath(); ctx2.moveTo(x+0.5, 8); ctx2.lineTo(x+0.5, ch-22); ctx2.stroke();
      const label = (f >= 1000) ? (f/1000)+'k' : String(f);
      ctx2.fillStyle = '#cfeff7';
      ctx2.fillText(label, x+0.5, ch - 18);
    }

    // RMS value + meter
    ctx2.fillStyle = '#9fbfd6';
    ctx2.font = '12px monospace';
    ctx2.textAlign = 'left';
    ctx2.textBaseline = 'top';
    const dbLabel = dbfs.toFixed(1) + ' dBFS';
    ctx2.fillText('Level: ' + dbLabel, leftPad + 6, 6);

    const meterW = 140, meterH = 8;
    const meterX = leftPad + 6, meterY = 26;
    const meterNorm = Math.max(0, Math.min(1, (dbfs - dBBottom) / dBRange));
    ctx2.fillStyle = '#0e2a2f';
    ctx2.fillRect(meterX, meterY, meterW, meterH);
    ctx2.fillStyle = '#38bdf8';
    ctx2.fillRect(meterX, meterY, meterW * meterNorm, meterH);
    ctx2.strokeStyle = '#072f36';
    ctx2.strokeRect(meterX, meterY, meterW, meterH);

    // legend
    ctx2.fillStyle = '#9fbfd6';
    ctx2.font = '11px monospace';
    ctx2.fillText('Freq (Hz) / Level (dB)', leftPad + 6, ch - 4);

  } else {
    // idle animation
    ctx2.fillStyle = '#243447';
    for(let i=0;i<64;i++){
      const x = i*(canvas.clientWidth/64), h = (Math.sin((Date.now()/300)+i)*0.4+0.5)*(canvas.clientHeight/3);
      ctx2.fillRect(x, canvas.clientHeight/2 - h/2, canvas.clientWidth/64*0.85, h);
    }
  }

  requestAnimationFrame(drawViz);
}
requestAnimationFrame(drawViz);
</script>
</body>
</html>
