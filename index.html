<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Demucs Player — 完全版</title>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

<style>
/* ---- 基本UI ---- */
body{background:#0f1115;color:#eaeaf0;margin:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto}
main{max-width:960px;margin:18px auto;padding:14px}
.top{display:grid;grid-template-columns:90px 1fr 90px;gap:16px;align-items:center}
canvas{width:100%;height:300px;background:#0b0d12;border-radius:12px;display:block}
.btn{background:linear-gradient(90deg,#38bdf8,#4ade80);color:#012;border:none;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer}
.small{font-size:13px;color:#b8cbe0}
.log{background:#071018;color:#9fbfd6;font-size:.85rem;border-radius:8px;padding:8px;max-height:160px;overflow:auto;white-space:pre-wrap}

/* 縦スライダー（デフォルト） */
.v-slider{display:flex;flex-direction:column;align-items:center;height:180px}
.v-label{font-size:13px;color:#b8cbe0;margin-bottom:12px}
.slider-vert{width:150px;height:22px;transform:rotate(-90deg);margin-top:28px}

/* レスポンシブ: 縦画面・小幅でスライダーを横にしてcanvas下へ */
@media (orientation: portrait), (max-width:760px) {
  .top{grid-template-columns:1fr;grid-auto-rows:auto;gap:10px}
  .v-slider{flex-direction:row;justify-content:space-between;align-items:center;height:auto;padding:8px 6px}
  .v-label{margin-bottom:0;margin-right:8px;font-size:12px;width:58px;text-align:left}
  .slider-vert{transform:none;width:48%;margin-top:0;height:22px}
  main{padding:12px}
}
</style>
</head>
<body>
<main>
  <h2 style="margin:0 0 8px 0">Demucs Player</h2>

  <div style="display:flex;gap:8px;align-items:center;margin-bottom:10px">
    <label id="zipLabel" for="zipInput" class="btn">ZIPを読み込む</label>
    <label id="filesLabel" for="filesInput" class="btn">2ファイル選択</label>
    <button id="playBtn" class="btn" disabled>再生</button>
    <button id="stopBtn" class="btn" disabled>停止</button>
  </div>

  <div class="top">
    <div class="v-slider" id="vslider-v">
      <div class="v-label">Vocals</div>
      <input id="volV" class="slider-vert" type="range" min="0" max="1" step="0.01" value="1">
    </div>

    <canvas id="viz" aria-hidden="true"></canvas>

    <div class="v-slider" id="vslider-b">
      <div class="v-label">Backing</div>
      <input id="volB" class="slider-vert" type="range" min="0" max="1" step="0.01" value="1">
    </div>
  </div>

  <div style="margin-top:14px">
    <input id="seek" type="range" min="0" max="1" step="0.01" value="0" style="width:100%">
    <div style="display:flex;justify-content:space-between;margin-top:6px">
      <small id="cur">0:00</small>
      <small id="total">0:00</small>
    </div>

    <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
      <div class="small">Master</div>
      <input id="master" type="range" min="0" max="1" step="0.01" value="1" style="flex:1">
      <div id="filename" class="small" style="width:220px;text-align:right">未選択</div>
    </div>

    <pre id="log" class="log">ready
</pre>
  </div>
</main>

<input id="zipInput" type="file" accept=".zip" hidden>
<input id="filesInput" type="file" accept=".wav,.mp3,.m4a,.aac,.ogg" multiple hidden>

<script>
/* ---------- ユーティリティ ---------- */
const logEl = document.getElementById('log');
function log(...a){ try{ logEl.textContent += a.join(' ') + '\\n'; logEl.scrollTop = 1e9; }catch(e){} }

/* DOM refs */
const zipInput = document.getElementById('zipInput');
const filesInput = document.getElementById('filesInput');
const playBtn = document.getElementById('playBtn');
const stopBtn = document.getElementById('stopBtn');
const seek = document.getElementById('seek');
const curEl = document.getElementById('cur');
const totalEl = document.getElementById('total');
const volV = document.getElementById('volV');
const volB = document.getElementById('volB');
const master = document.getElementById('master');
const filenameEl = document.getElementById('filename');

/* ---------- Audio 状態 ---------- */
let audioCtx = null;
let analyser = null;
let masterGain = null, gainV = null, gainB = null;
let tracks = { vocals: null, backing: null }; // { mode:'buffer'|'media', buffer, el, node, fileName }
let bufferSources = { vocals: null, backing: null }; // { node, offset, startedAt }
let isPlaying = false;
let pausedOffset = 0;
let resumeAfterVisible = false;

/* ---------- AudioContext 作成 ---------- */
function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 512;
  analyser.minDecibels = -100;
  analyser.maxDecibels = -20;
  masterGain = audioCtx.createGain();
  gainV = audioCtx.createGain();
  gainB = audioCtx.createGain();
  // 初期値をDOMから取得（ctx作られる前のスライダー状態と一致させる）
  gainV.gain.value = Number(volV.value || 1);
  gainB.gain.value = Number(volB.value || 1);
  masterGain.gain.value = Number(master.value || 1);
  gainV.connect(masterGain);
  gainB.connect(masterGain);
  masterGain.connect(analyser);
  analyser.connect(audioCtx.destination);
  log('AudioContext created (state=' + audioCtx.state + ')');
}

/* ---------- デコードヘルパ ---------- */
async function tryDecode(arrayBuffer){
  try{
    ensureAudio();
    return await new Promise((res, rej) => audioCtx.decodeAudioData(arrayBuffer.slice(0), res, rej));
  }catch(e){
    log('decodeAudioData failed', e && e.message ? e.message : e);
    return null;
  }
}

/* ---------- create media element fallback ---------- */
function createMediaFromBlob(blob, name){
  const url = URL.createObjectURL(blob);
  const el = new Audio(url);
  el.preload = 'auto';
  el.setAttribute('playsinline','');
  el.playsInline = true;
  el.style.display = 'none';
  document.body.appendChild(el);
  audioElementsKeeper.push(el);
  el.addEventListener('loadedmetadata', ()=>{
    log('loadedmetadata', name, el.duration);
    try{ const d = calcDuration(); if(isFinite(d)){ seek.max = d; totalEl.textContent = fmt(d); } }catch(e){}
  });
  // timeupdate updating seek when media-only used
  el.addEventListener('timeupdate', ()=> {
    if(!isPlaying) return;
    // keep seek synced when both media or single media playing
    try{
      const t = getCurrentTime();
      if(!isNaN(t) && !isFinite(t) === false){} // noop just safe
    }catch(e){}
  });
  return { mode:'media', el, blobUrl:url, fileName:name };
}
const audioElementsKeeper = []; // keep references to audio elements to avoid GC

/* ---------- 小ヘルパ ---------- */
function fmt(sec){ if(!isFinite(sec)) return '0:00'; sec = Math.max(0, Math.floor(sec)); const m = Math.floor(sec/60); const s = sec%60; return `${m}:${s.toString().padStart(2,'0')}`; }

function calcDuration(){
  if(tracks.vocals?.mode === 'buffer' && tracks.backing?.mode === 'buffer'){
    return Math.min(tracks.vocals.buffer.duration, tracks.backing.buffer.duration);
  }
  if(tracks.vocals?.mode === 'media' && tracks.backing?.mode === 'media' && tracks.vocals.el.duration && tracks.backing.el.duration){
    return Math.min(tracks.vocals.el.duration, tracks.backing.el.duration);
  }
  if(tracks.vocals?.mode === 'buffer' && tracks.backing?.mode === 'media' && tracks.backing.el.duration){
    return Math.min(tracks.vocals.buffer.duration, tracks.backing.el.duration);
  }
  if(tracks.vocals?.mode === 'media' && tracks.backing?.mode === 'buffer' && tracks.vocals.el.duration){
    return Math.min(tracks.vocals.el.duration, tracks.backing.buffer.duration);
  }
  return Infinity;
}

/* ---------- ファイル読み込み（ZIP & ファイル） ---------- */
/* ZIP ラベルクリック補助 */
document.getElementById('zipLabel').addEventListener('click', ()=>{ try{ zipInput.click(); }catch(e){} });
document.getElementById('filesLabel').addEventListener('click', ()=>{ try{ filesInput.click(); }catch(e){} });

zipInput.addEventListener('change', async ()=>{
  const f = zipInput.files[0]; zipInput.value = '';
  if(!f) return;
  log('ZIP select', f.name);
  try{
    const zip = await JSZip.loadAsync(f);
    const names = Object.keys(zip.files).filter(n => !zip.files[n].dir && /\.(wav|mp3|m4a|aac|ogg)$/i.test(n));
    if(names.length < 2){ alert('ZIP に音声ファイルが2つ以上必要です'); return; }
    const vName = names.find(n=>/vocals?/i.test(n)) || names[0];
    const bName = names.find(n=>/(inst|back|no[_-]?vocals?)/i.test(n) && n!==vName) || names.find(n=>n!==vName) || names[1];
    log('selected entries', vName, bName);
    const vAB = await zip.file(vName).async('arraybuffer');
    const bAB = await zip.file(bName).async('arraybuffer');
    const bufV = await tryDecode(vAB);
    const bufB = await tryDecode(bAB);
    if(bufV && bufB){
      tracks.vocals = { mode:'buffer', buffer:bufV, fileName:vName };
      tracks.backing = { mode:'buffer', buffer:bufB, fileName:bName };
    }else{
      tracks.vocals = createMediaFromBlob(new Blob([vAB]), vName);
      tracks.backing = createMediaFromBlob(new Blob([bAB]), bName);
    }
    filenameEl.textContent = `${tracks.vocals.fileName} / ${tracks.backing.fileName}`;
    const d = calcDuration(); if(isFinite(d)){ seek.max = d; totalEl.textContent = fmt(d); }
    playBtn.disabled = stopBtn.disabled = false;
    log('tracks set', {vocals:tracks.vocals.fileName, backing:tracks.backing.fileName, modes:[tracks.vocals.mode, tracks.backing.mode]});
  }catch(e){
    console.error(e);
    log('ZIP 読み込み失敗', e && e.message ? e.message : e);
    alert('ZIP の読み込みに失敗しました');
  }
});

filesInput.addEventListener('change', async ()=>{
  const files = Array.from(filesInput.files); filesInput.value = '';
  if(files.length < 2){ alert('2ファイル選択してください'); return; }
  const vocalsFile = files.find(f=>/vocals/i.test(f.name)) || files[0];
  const backingFile = files.find(f=>/(no_vocals|no-vocals|back|inst|instrumental)/i.test(f.name)) || files[1];
  log('files select', vocalsFile.name, backingFile.name);
  try{
    const vAb = await vocalsFile.arrayBuffer();
    const bAb = await backingFile.arrayBuffer();
    const bufV = await tryDecode(vAb);
    const bufB = await tryDecode(bAb);
    if(bufV && bufB){
      tracks.vocals = { mode:'buffer', buffer:bufV, fileName:vocalsFile.name };
      tracks.backing = { mode:'buffer', buffer:bufB, fileName:backingFile.name };
    }else{
      tracks.vocals = createMediaFromBlob(new Blob([vAb]), vocalsFile.name);
      tracks.backing = createMediaFromBlob(new Blob([bAb]), backingFile.name);
    }
    filenameEl.textContent = `${tracks.vocals.fileName} / ${tracks.backing.fileName}`;
    const d = calcDuration(); if(isFinite(d)){ seek.max = d; totalEl.textContent = fmt(d); }
    playBtn.disabled = stopBtn.disabled = false;
    log('tracks set', {vocals:tracks.vocals.fileName, backing:tracks.backing.fileName});
  }catch(e){
    log('files load error', e && e.message ? e.message : e);
    alert('ファイル読み込みでエラーが発生しました');
  }
});

/* ---------- Buffer 再生関連 ---------- */
function stopBufferSource(role){
  const s = bufferSources[role];
  if(s && s.node){
    try{ s.node.stop(); }catch(e){/*ignore*/ }
  }
  bufferSources[role] = null;
}

function startBufferSource(role, offsetSec){
  if(!audioCtx) ensureAudio();
  stopBufferSource(role);
  const now = audioCtx.currentTime;
  const src = audioCtx.createBufferSource();
  src.buffer = tracks[role].buffer;
  src.connect(role === 'vocals' ? gainV : gainB);
  src.loop = false;
  src.start(now, offsetSec);
  bufferSources[role] = { node: src, offset: offsetSec, startedAt: now };
  src.onended = ()=>{ if(!src.loop) { /* if both ended, stopAll will set play state */ } };
}

function stopBufferPlayback(){
  ['vocals','backing'].forEach(k=>{ stopBufferSource(k); });
}

function startBufferPlayback(offsetSec){
  if(!audioCtx) ensureAudio();
  stopBufferPlayback();
  const now = audioCtx.currentTime;
  const sV = audioCtx.createBufferSource(); sV.buffer = tracks.vocals.buffer; sV.connect(gainV);
  const sB = audioCtx.createBufferSource(); sB.buffer = tracks.backing.buffer; sB.connect(gainB);
  sV.loop = sB.loop = false;
  sV.start(now, offsetSec);
  sB.start(now, offsetSec);
  bufferSources.vocals = { node: sV, offset: offsetSec, startedAt: now };
  bufferSources.backing = { node: sB, offset: offsetSec, startedAt: now };
  sV.onended = ()=>{ if(!sV.loop) { stopAll(); } };
  // set playing state
  isPlaying = true; playBtn.textContent = '停止';
}

/* ---------- MediaElementSource 接続ヘルパ ---------- */
function ensureMediaNode(role){
  const t = tracks[role];
  if(!t || t.mode !== 'media' || !t.el) return;
  try{
    if(!audioCtx) ensureAudio();
    // disconnect existing node (some browsers require re-create after background)
    if(t.node){
      try{ t.node.disconnect(); }catch(e){}
      t.node = null;
    }
    t.node = audioCtx.createMediaElementSource(t.el);
    t.node.connect(role==='vocals' ? gainV : gainB);
    log('media node connected', role);
  }catch(e){
    log('createMediaElementSource failed for', role, e && e.message ? e.message : e);
  }
}

/* ---------- 開始 / 停止 ---------- */
async function startAll(){
  if(!tracks.vocals || !tracks.backing){ alert('ファイルを読み込んでください'); return; }
  ensureAudio();
  try{ if(audioCtx.state === 'suspended') await audioCtx.resume(); }catch(e){ log('resume error', e && e.message ? e.message : e); }
  // update gain values
  try{ gainV.gain.value = Number(volV.value); gainB.gain.value = Number(volB.value); masterGain.gain.value = Number(master.value); }catch(e){}
  if(tracks.vocals.mode === 'buffer' && tracks.backing.mode === 'buffer'){
    const offset = Number(seek.value) || 0;
    startBufferPlayback(offset);
    isPlaying = true; playBtn.textContent = '停止'; log('started buffer at', offset);
    return;
  }
  // media path
  for(const role of ['vocals','backing']){
    const t = tracks[role];
    if(t?.mode === 'media' && t.el){
      ensureMediaNode(role);
      if(t.el.readyState < 3){
        await new Promise(resolve=>{
          const onCan = ()=>{ t.el.removeEventListener('canplay', onCan); resolve(); };
          t.el.addEventListener('canplay', onCan);
          setTimeout(resolve, 2000);
        });
      }
      try{ t.el.currentTime = Number(seek.value) || 0; }catch(e){}
    }
  }
  const promises = [];
  if(tracks.vocals.mode === 'media' && tracks.vocals.el) promises.push(tracks.vocals.el.play().catch(e=>{ log('vocals.play fail', e && e.name); return e; }));
  if(tracks.backing.mode === 'media' && tracks.backing.el) promises.push(tracks.backing.el.play().catch(e=>{ log('backing.play fail', e && e.name); return e; }));
  await Promise.all(promises);
  isPlaying = true; playBtn.textContent = '停止';
  log('media play results');
}

function stopAll(){
  // buffers: remember position then stop
  if(tracks.vocals?.mode === 'buffer' || tracks.backing?.mode === 'buffer'){
    try{ pausedOffset = getBufferCurrent(); }catch(e){ pausedOffset = Number(seek.value) || 0; }
    stopBufferPlayback();
  }
  // media: pause elements
  ['vocals','backing'].forEach(role=>{
    const t = tracks[role];
    if(t?.mode === 'media' && t.el){
      try{ t.el.pause(); }catch(e){ log('pause failed', e && e.message ? e.message : e); }
    }
  });
  isPlaying = false;
  playBtn.textContent = '再生';
}

/* ---------- 再生位置取得 ---------- */
function getBufferCurrent(){
  // assume vocals buffer source tracks.vocals exists
  const a = bufferSources.vocals;
  if(a && a.startedAt) return a.offset + (audioCtx.currentTime - a.startedAt);
  return pausedOffset || Number(seek.value) || 0;
}

function getCurrentTime(){
  try{
    if(tracks.vocals?.mode === 'buffer' || tracks.backing?.mode === 'buffer') return getBufferCurrent();
    if(tracks.vocals?.mode === 'media' && tracks.backing?.mode === 'media' && tracks.vocals.el && tracks.backing.el){
      return Math.min(tracks.vocals.el.currentTime || 0, tracks.backing.el.currentTime || 0);
    }
    if(tracks.vocals?.mode === 'media' && tracks.vocals.el) return tracks.vocals.el.currentTime || 0;
    if(tracks.backing?.mode === 'media' && tracks.backing.el) return tracks.backing.el.currentTime || 0;
    return 0;
  }catch(e){ return 0; }
}

/* ---------- シーク中に再生継続（最重要） ---------- */
async function seekWhilePlaying(time){
  if(!tracks.vocals || !tracks.backing) return;
  ensureAudio();
  try{ if(audioCtx.state === 'suspended') await audioCtx.resume(); }catch(e){ log('resume failed', e && e.message ? e.message : e); }
  // both buffers -> restart both synchronized
  if(tracks.vocals.mode === 'buffer' && tracks.backing.mode === 'buffer'){
    startBufferPlayback(Number(time) || 0);
    return;
  }
  // mixed/media: set media currentTime then restart buffer ones
  const mediaPromises = [];
  for(const role of ['vocals','backing']){
    const t = tracks[role];
    if(t?.mode === 'media' && t.el){
      try{ t.el.currentTime = Number(time) || 0; }catch(e){ log('set currentTime failed', role, e && e.message ? e.message : e); }
      // attempt to play (may be already playing)
      mediaPromises.push(t.el.play().catch(e=>{ log('media play during seek failed', role, e && e.name); return e; }));
    }
  }
  // restart buffer sources individually (so they align with media)
  for(const role of ['vocals','backing']){
    const t = tracks[role];
    if(t?.mode === 'buffer'){
      stopBufferSource(role);
      startBufferSource(role, Number(time) || 0);
    }
  }
  try{ await Promise.all(mediaPromises); }catch(e){}
  isPlaying = true; playBtn.textContent = '停止';
}

/* ---------- UI wiring ---------- */
playBtn.addEventListener('click', ()=>{ if(isPlaying) stopAll(); else startAll(); });
stopBtn.addEventListener('click', ()=> stopAll());

let lastSeekByUser = false;
seek.addEventListener('input', async ()=>{
  lastSeekByUser = true;
  const v = Number(seek.value);
  curEl.textContent = fmt(v);
  if(isPlaying){
    // 再生中：停止せずに即再生継続（seekWhilePlaying）
    pausedOffset = v;
    await seekWhilePlaying(v);
  }else{
    // 停止中：位置だけ更新。メディアがある場合は currentTime 反映（再生は開始しない）
    pausedOffset = v;
    try{
      for(const role of ['vocals','backing']){
        const t = tracks[role];
        if(t?.mode === 'media' && t.el){
          try{ t.el.currentTime = v; }catch(e){}
        }
      }
    }catch(e){}
  }
});
seek.addEventListener('change', ()=>{ lastSeekByUser = false; });

volV.addEventListener('input', ()=>{ ensureAudio(); if(gainV) gainV.gain.value = Number(volV.value); });
volB.addEventListener('input', ()=>{ ensureAudio(); if(gainB) gainB.gain.value = Number(volB.value); });
master.addEventListener('input', ()=>{ ensureAudio(); if(masterGain) masterGain.gain.value = Number(master.value); });

setInterval(()=>{
  if(isPlaying){
    try{
      const c = getCurrentTime();
      if(!lastSeekByUser){ seek.value = c; curEl.textContent = fmt(c); }
    }catch(e){}
  }
},200);

/* ---------- バックグラウンド復帰対応 ---------- */
async function onBecomeHidden(){
  if(!isPlaying) return;
  try{ pausedOffset = getCurrentTime(); }catch(e){ pausedOffset = Number(seek.value) || 0; }
  log('becoming hidden, saving pos', pausedOffset);
  stopAll();
  resumeAfterVisible = true;
}

async function onBecomeVisible(){
  if(!resumeAfterVisible) return;
  resumeAfterVisible = false;
  log('becoming visible, try resume at', pausedOffset);
  if(!tracks.vocals || !tracks.backing) return;
  ensureAudio();
  try{ if(audioCtx.state === 'suspended') await audioCtx.resume(); }catch(e){}
  // media nodes may need re-creation (Safari)
  for(const role of ['vocals','backing']){
    const t = tracks[role];
    if(t?.mode === 'media' && t.el){
      try{
        if(t.node){
          try{ t.node.disconnect(); }catch(e){}
          t.node = null;
        }
        t.node = audioCtx.createMediaElementSource(t.el);
        t.node.connect(role==='vocals'?gainV:gainB);
      }catch(e){ log('recreate media node failed', role, e && e.message ? e.message : e); }
    }
  }
  // set UI position
  seek.value = pausedOffset;
  curEl.textContent = fmt(pausedOffset);
  // resume playback at pausedOffset
  if(tracks.vocals.mode === 'buffer' && tracks.backing.mode === 'buffer'){
    startBufferPlayback(pausedOffset);
  } else {
    // set media currentTime then play; restart any buffer sources
    for(const role of ['vocals','backing']){
      const t = tracks[role];
      if(t?.mode === 'media' && t.el){
        try{ t.el.currentTime = pausedOffset; }catch(e){}
      }
    }
    const promises = [];
    if(tracks.vocals.mode === 'media' && tracks.vocals.el) promises.push(tracks.vocals.el.play().catch(()=>{}));
    if(tracks.backing.mode === 'media' && tracks.backing.el) promises.push(tracks.backing.el.play().catch(()=>{}));
    // restart buffers if present
    for(const role of ['vocals','backing']){
      if(tracks[role]?.mode === 'buffer'){
        stopBufferSource(role);
        startBufferSource(role, pausedOffset);
      }
    }
    try{ await Promise.all(promises); }catch(e){}
    isPlaying = true; playBtn.textContent = '停止';
  }
}

/* visibility/page events */
document.addEventListener('visibilitychange', ()=>{ if(document.hidden) onBecomeHidden(); else onBecomeVisible(); });
window.addEventListener('pagehide', ()=>{ if(document.hidden) onBecomeHidden(); });
window.addEventListener('pageshow', ()=>{ if(!document.hidden) onBecomeVisible(); });

/* ---------- Visualizer（周波数ラベル + dB 表示） ---------- */
const canvas = document.getElementById('viz');
const canvasCtx = canvas.getContext('2d');
function resizeCanvas(){
  const ratio = window.devicePixelRatio || 1;
  canvas.width = Math.floor(canvas.clientWidth * ratio);
  canvas.height = Math.floor(canvas.clientHeight * ratio);
  canvasCtx.setTransform(ratio,0,0,ratio,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let floatFreq = null;
let timeDomain = null;

function drawViz(){
  const cw = canvas.clientWidth, ch = canvas.clientHeight;
  canvasCtx.clearRect(0,0,cw,ch);
  const leftPad = 80, topMargin = 10, bottomMargin = 44;
  if(analyser && audioCtx){
    const binCount = analyser.frequencyBinCount;
    if(!floatFreq || floatFreq.length !== binCount){
      floatFreq = new Float32Array(binCount);
      timeDomain = new Float32Array(analyser.fftSize);
    }
    analyser.getFloatFrequencyData(floatFreq);
    analyser.getFloatTimeDomainData(timeDomain);
    // RMS -> dBFS
    let sum = 0;
    for(let i=0;i<timeDomain.length;i++) sum += timeDomain[i]*timeDomain[i];
    const rms = Math.sqrt(sum / timeDomain.length) || 0.000001;
    const dbfs = 20 * Math.log10(rms);
    const dBTop = analyser.maxDecibels, dBBottom = analyser.minDecibels, dBRange = dBTop - dBBottom;
    canvasCtx.font = '11px monospace'; canvasCtx.textAlign = 'right'; canvasCtx.textBaseline = 'middle';
    const usableH = ch - topMargin - bottomMargin;
    // dB grid & labels
    for(let d = Math.ceil(dBBottom/10)*10; d <= dBTop; d += 10){
      const y = topMargin + ((dBTop - d) / dBRange) * usableH;
      canvasCtx.fillStyle = '#142b31';
      canvasCtx.fillRect(leftPad - 10, y - 0.5, cw - leftPad - 12, 1);
      canvasCtx.fillStyle = '#9fbfd6';
      canvasCtx.fillText(String(d) + ' dB', leftPad - 12, y);
    }
    // spectral bars
    const nyquist = audioCtx.sampleRate / 2;
    const binFreq = audioCtx.sampleRate / analyser.fftSize;
    const usableW = cw - leftPad - 12;
    const barW = Math.max(1, usableW / floatFreq.length);
    for(let i=0;i<floatFreq.length;i++){
      const fdb = floatFreq[i];
      let v = (fdb - dBBottom) / dBRange; v = Math.max(0, Math.min(1, v));
      const x = leftPad + i * barW;
      const h = v * usableH;
      canvasCtx.fillStyle = (i%2) ? '#38bdf8' : '#7dd3fc';
      canvasCtx.fillRect(x, topMargin + (usableH - h), Math.max(1, barW*0.9), h);
    }
    // log-spaced freq labels
    const freqs = [50,75,100,150,200,300,400,500,750,1000,1500,2000,3000,5000,8000,10000,15000,20000];
    canvasCtx.fillStyle = '#cfeff7';
    canvasCtx.font = '11px monospace';
    canvasCtx.textAlign = 'center';
    canvasCtx.textBaseline = 'top';
    const logMin = Math.log10(20), logMax = Math.log10(Math.max(20000, nyquist));
    let lastLabelX = -9999;
    const minLabelSpacing = 40;
    for(const f of freqs){
      if(f > nyquist) continue;
      const lx = Math.log10(Math.max(f,20));
      const pos = (lx - logMin) / (logMax - logMin);
      const x = leftPad + pos * usableW;
      if(x - lastLabelX < minLabelSpacing){
        // draw tick only
        canvasCtx.strokeStyle = '#244e57';
        canvasCtx.beginPath(); canvasCtx.moveTo(x+0.5, topMargin+2); canvasCtx.lineTo(x+0.5, topMargin+usableH-2); canvasCtx.stroke();
        continue;
      }
      canvasCtx.strokeStyle = '#244e57';
      canvasCtx.beginPath(); canvasCtx.moveTo(x+0.5, topMargin+2); canvasCtx.lineTo(x+0.5, topMargin+usableH-2); canvasCtx.stroke();
      const label = (f >= 1000) ? (f/1000)+'k' : String(f);
      canvasCtx.fillStyle = '#cfeff7';
      canvasCtx.fillText(label, x+0.5, topMargin + usableH + 6);
      lastLabelX = x;
    }
    // RMS label + meter
    canvasCtx.fillStyle = '#9fbfd6';
    canvasCtx.font = '12px monospace';
    canvasCtx.textAlign = 'left';
    canvasCtx.textBaseline = 'top';
    canvasCtx.fillText('Level: ' + dbfs.toFixed(1) + ' dBFS', leftPad + 6, 6);
    const meterW = Math.min(usableW * 0.38, 180), meterH = 8;
    const meterX = leftPad + 6, meterY = 28;
    const meterNorm = Math.max(0, Math.min(1, (dbfs - dBBottom) / dBRange));
    canvasCtx.fillStyle = '#0e2a2f';
    canvasCtx.fillRect(meterX, meterY, meterW, meterH);
    canvasCtx.fillStyle = '#38bdf8';
    canvasCtx.fillRect(meterX, meterY, meterW * meterNorm, meterH);
    canvasCtx.strokeStyle = '#072f36';
    canvasCtx.strokeRect(meterX, meterY, meterW, meterH);
    // legend
    canvasCtx.fillStyle = '#9fbfd6';
    canvasCtx.font = '11px monospace';
    canvasCtx.textAlign = 'left';
    canvasCtx.textBaseline = 'bottom';
    canvasCtx.fillText('Freq (Hz) / Level (dB)', leftPad + 6, ch - 6);
  } else {
    // idle bars
    canvasCtx.fillStyle = '#243447';
    for(let i=0;i<64;i++){
      const x = i*(canvas.clientWidth/64);
      const h = (Math.sin((Date.now()/300)+i)*0.4+0.5)*(canvas.clientHeight/3);
      canvasCtx.fillRect(x, canvas.clientHeight/2 - h/2, canvas.clientWidth/64*0.85, h);
    }
  }
  requestAnimationFrame(drawViz);
}
requestAnimationFrame(drawViz);

</script>
</body>
</html>
